GUI
https://github.com/fyne-io/fyne

enums
https://www.sohamkamani.com/golang/enums/
https://www.sohamkamani.com/golang/iota/

state tree for base cardinal directions.
state tree for base dimentions of shapes (1d) 1 color.
state machine for detecting edge.
at least 1 nearby(1 unit) square is different from current square.
if tracker 1 can visit all shape squares without finding tracker 2 while tracker 2 doesn't move.
tracker 1 is using a different shape than tracker 2.
window slide for grouping substates having common superstate.
read sequence, group, make new states and state graph from input sequence.
retry matching partially constructed graph with the next input.
if the first nodeName matches the next item in input keep matching till entire partial graph matches the input.
if first matches but doesn't get all the way through the graph it's a new path(starts with first match and ends at first mismatch) added onto the end.

github.com/nsf/jsondiff

1 = cycle
0 = no cycle

binary representation of cycles and their positions in graph


1's match count(111110011111 & 111110001111) / 1's count(111110011111 | 111110001111) >= .9
1+1+1+1+1+1+1+1+1/ 10 = 9/10



pattern detection + hierarchy
trackers for pattern tracking for each level
trackers for first node in each level
tracker for {`pattern start and end symbol ids`: [i, j]} for each level
levels above input level are for folding the cycles found in lower levels
cycles are found at each level simultaneously
input level is not necessarily the bottom level of patterns
input symbols are checked from bottom to top to determine presence
lowest level where input symbols are detected determine level of patterns used to check
input for patterns
if there is no lowest level then make new lowest level
each new input symobol might be the start of a new pattern
generated symbols for the higher levels are not in the set of input symbols
generated symbols are nested patterns
nested patterns don't always start with the first symbol
the input level bottom pattern increases as new patterns are added
symbo0 -> [all locations it has been seen]
each seen location can be the start of a new pattern
each new cycle in range [0, n] needs to make a new cycle at each upper level
each new cycle results in 1 new generated symbol at the end of the next upper level
each symbol in the lower level must be covered by at least 1 symbol in the next upper level
can't have 2 or more levels with only 1 self loop
same pattern happening later in sequence needs to be removed and parent symbol needs to refer to already stored pattern
q0 = input[i] is matched prediction
q0_f(input[i]) = true is matched prediction
table with headers interpreted as input to pattern levels
top down positional prediction
how to know row is header
row uses symbols already known
the symbols have children
others rows use data associated with correct prediction symbols with children use
the data is does not have a prediction function that correctly predicts symbols with children
if each item in row x can predict each item in a few other rows then it's the header
possible to make data have such wide prediction that not possible to find the header
header is usually the first row
bottom up prediction
sequence matching part of existing pattern visit upper levels and run prediction on input where currently reading
find "@" finding out it's part of higher level "email" symbol and running email prediction on current index of input
add in top down sequences with prediction functions into pattern levels before reading the table

expected input symbols
recognize bottom up and across
predict top down and across
for i, inputAtI := range input
if !recognize for input[i]
	run patternDetector(i, input[i])
else
	run [atomRecognized.prediction(i, input[i]) to build whatever expected structure or filter function]


atomRecognized.prediction
	if prediction fails
		remove data or send info to higher level prediction function
contextual state chart

computer code writing patterns and using parts of the pattern tree
to make pattern for when to put down pieces of text

higher level patterns from 1 graph (not same sequence but same if in between nodes were removed)
lower level patterns from different graph
input being multiple levels of structured sequence match the pattern structures the pattern detector makes
way for user to add shortcut words so user and stored patterns are on same page even with internal pattern names being generated
shortcut word happens at same time pattern happens
grid where 1 axis is time 1 axis is sequence
each point can be set to backtrack control to an earlier time and different sequence, replacing the simultaneous sequence
with a different sequence started earlier but comming after the sequence backtrack control was used from
1 axis for structure nodes to let backtrack commands be consistent for same structure
backtrack is true if prediction fails
making predictions while reading information