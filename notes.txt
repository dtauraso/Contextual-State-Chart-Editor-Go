GUI
https://github.com/fyne-io/fyne

enums
https://www.sohamkamani.com/golang/enums/
https://www.sohamkamani.com/golang/iota/

state tree for base cardinal directions.
state tree for base dimentions of shapes (1d) 1 color.
state machine for detecting edge.
at least 1 nearby(1 unit) square is different from current square.
if tracker 1 can visit all shape squares without finding tracker 2 while tracker 2 doesn't move.
tracker 1 is using a different shape than tracker 2.
window slide for grouping substates having common superstate.
read sequence, group, make new states and state graph from input sequence.
retry matching partially constructed graph with the next input.
if the first nodeName matches the next item in input keep matching till entire partial graph matches the input.
if first matches but doesn't get all the way through the graph it's a new path(starts with first match and ends at first mismatch) added onto the end.

github.com/nsf/jsondiff

1 = cycle
0 = no cycle

binary representation of cycles and their positions in graph


1's match count(111110011111 & 111110001111) / 1's count(111110011111 | 111110001111) >= .9
1+1+1+1+1+1+1+1+1/ 10 = 9/10



pattern detection + hierarchy
trackers for pattern tracking for each level
trackers for first node in each level
tracker for {`pattern start and end symbol ids`: [i, j]} for each level
levels above input level are for folding the cycles found in lower levels
cycles are found at each level simultaneously
input level is not necessarily the bottom level of patterns
input symbols are checked from bottom to top to determine presence
lowest level where input symbols are detected determine level of patterns used to check
input for patterns
if there is no lowest level then make new lowest level
each new input symobol might be the start of a new pattern
generated symbols for the higher levels are not in the set of input symbols
generated symbols are nested patterns
nested patterns don't always start with the first symbol
the input level bottom pattern increases as new patterns are added
symbo0 -> [all locations it has been seen]
each seen location can be the start of a new pattern
each new cycle in range [0, n] needs to make a new cycle at each upper level
each new cycle results in 1 new generated symbol at the end of the next upper level
each symbol in the lower level must be covered by at least 1 symbol in the next upper level
can't have 2 or more levels with only 1 self loop
same pattern happening later in sequence needs to be removed and parent symbol needs to refer to already stored pattern
q0 = input[i] is matched prediction
q0_f(input[i]) = true is matched prediction
table with headers interpreted as input to pattern levels
top down positional prediction
how to know row is header
row uses symbols already known
the symbols have children
others rows use data associated with correct prediction symbols with children use
the data is does not have a prediction function that correctly predicts symbols with children
if each item in row x can predict each item in a few other rows then it's the header
possible to make data have such wide prediction that not possible to find the header
header is usually the first row
bottom up prediction
sequence matching part of existing pattern visit upper levels and run prediction on input where currently reading
find "@" finding out it's part of higher level "email" symbol and running email prediction on current index of input
add in top down sequences with prediction functions into pattern levels before reading the table

expected input symbols
recognize bottom up and across
predict top down and across
for i, inputAtI := range input
if !recognize for input[i]
	run patternDetector(i, input[i])
else
	run [atomRecognized.prediction(i, input[i]) to build whatever expected structure or filter function]


atomRecognized.prediction
	if prediction fails
		remove data or send info to higher level prediction function
contextual state chart

computer code writing patterns and using parts of the pattern tree
to make pattern for when to put down pieces of text

higher level patterns from 1 graph (not same sequence but same if in between nodes were removed)
lower level patterns from different graph
input being multiple levels of structured sequence match the pattern structures the pattern detector makes
way for user to add shortcut words so user and stored patterns are on same page even with internal pattern names being generated
shortcut word happens at same time pattern happens
grid where 1 axis is time 1 axis is sequence
each point can be set to backtrack control to an earlier time and different sequence, replacing the simultaneous sequence
with a different sequence started earlier but comming after the sequence backtrack control was used from
1 axis for structure nodes to let backtrack commands be consistent for same structure
backtrack is true if prediction fails
making predictions while reading information
each element of the same property happening right next to other element in same time or same space is part of same group
pattern is loop
inhibition is when pattern stops

atom tree intersect with atom trees in timeline a
run timeline b at same time as a
atom tree interesction is the pattern
master time line for a and b

run only b
recognize atom tree as matching with intersect atom tree
find sibling patterns that was run at same time with b
run sibling pattern
do recognizing and running sibling pattern as same timestep as b

more than 1 timeline running means training
a partial match (keep differences found during intersection) during training means different data being added makes a new context on the state
first round training must use full match
highest number of node and content matches during intersection during non-training
each intersection atom tree has is separate to represent slightly different contexts among intersection trees
intesection, union
change in time and change in space is the pattern
save items from observe grid to table holding last tree data about data point
connect same data points together
edge is when 2 data points are different but they are at same time
numerical barrier data point that stops reading of timeline until a data point barrier of same number is read in a different timeline
all nested timelines must have a common theme so they don't collect nested timelines from other higher level timelines
the content in the higher level atom always wins
connecting data points across timeslines at same time and higher level time lines
compute the interesction nodes then use them to add hierarchy to timelines

intersect points on same line when there is a loop and the loop node holds position of timeline is was made from and looped points are 1 level below
intersect points on different lines at same time and let the higher level timeline name win if a lower level uses a timeline from a different theme
loops are separate timelines even if they start and end at same time as non loops
mattern match: highest in common count with weights stronger each level closer to root node
pattern match: loop match, finding right intersection node that's closes in common with input to start prediction or running siblings
program with if statements and conclusions
funnel paragraph with conclusion and premises
take the program sequences for if statements and conclusions,
match it into the funnel paragraph tree,
copy the level, but change the links so they link to the same lower words as their counterpart intersection nodes it to the funnel paragraph tree as new sub timeline,
make a new timeline where english works are now used in the sequence of if statements and conclusions
"condition" node of the program timeline will find the "condition" node of the english timeline
the "condition" node of the program timeline will copy itself under the english timeline,
but take the child nodes from the english timeline "condition" node

	
n timelines = n simultaneous data point changes
repeating across n timelines = hierarchy


0, move, 0, move, 2, move, 2, move
cycles length >= 1
	0: 0 move
	2: 2 move
repeats with n items before 1 item repeats
	move:
		move1: move 0
		move2: move 2

move1, barista, move1, barista, move2, barista
cycles length >= 1
	move1: move1 barista
repeats with n items before 1 item repeats
	barista
		barista1: barista move1
		barista2: barista move2
	

y = 1/2 x

n time to go 2 units of x axis
y/n units each time n for 1 unit of y axis
convert slope into time path of slightly changing x, y values

hold y=+-1x diagonals and straight lines as the default slopes for finding the next color
if the points don't match the next expected color try all directions till a point matches
the matching point and the previous point can be used to calculate the slope for the non-default direction
timeline A has same point repeated at same time timeline B has points
A's point is repeated enough times it can be used as a shortcut for B's points

for all bottom level sequences found
intersect atom trees
if no match
go up 1 level
if match
stop


predict(match what is stored with input) and fit(intersection with small atom trees. if no match move up 1 level and repeat with next level of atom trees) sequence to atom tree
keep items stored for longer period of time