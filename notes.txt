GUI
https://github.com/fyne-io/fyne

enums
https://www.sohamkamani.com/golang/enums/
https://www.sohamkamani.com/golang/iota/

state tree for base cardinal directions.
state tree for base dimentions of shapes (1d) 1 color.
state machine for detecting edge.
at least 1 nearby(1 unit) square is different from current square.
if tracker 1 can visit all shape squares without finding tracker 2 while tracker 2 doesn't move.
tracker 1 is using a different shape than tracker 2.
window slide for grouping substates having common superstate.
read sequence, group, make new states and state graph from input sequence.
retry matching partially constructed graph with the next input.
if the first nodeName matches the next item in input keep matching till entire partial graph matches the input.
if first matches but doesn't get all the way through the graph it's a new path(starts with first match and ends at first mismatch) added onto the end.

github.com/nsf/jsondiff

1 = cycle
0 = no cycle

binary representation of cycles and their positions in graph


1's match count(111110011111 & 111110001111) / 1's count(111110011111 | 111110001111) >= .9
1+1+1+1+1+1+1+1+1/ 10 = 9/10



pattern detection + hierarchy
trackers for pattern tracking for each level
trackers for first node in each level
tracker for {`pattern start and end symbol ids`: [i, j]} for each level
levels above input level are for folding the cycles found in lower levels
cycles are found at each level simultaneously
input level is not necessarily the bottom level of patterns
input symbols are checked from bottom to top to determine presence
lowest level where input symbols are detected determine level of patterns used to check
input for patterns
if there is no lowest level then make new lowest level
each new input symobol might be the start of a new pattern
generated symbols for the higher levels are not in the set of input symbols
generated symbols are nested patterns
nested patterns don't always start with the first symbol
the input level bottom pattern increases as new patterns are added
symbo0 -> [all locations it has been seen]
each seen location can be the start of a new pattern
each new cycle in range [0, n] needs to make a new cycle at each upper level
each new cycle results in 1 new generated symbol at the end of the next upper level
each symbol in the lower level must be covered by at least 1 symbol in the next upper level
can't have 2 or more levels with only 1 self loop
same pattern happening later in sequence needs to be removed and parent symbol needs to refer to already stored pattern
q0 = input[i] is matched prediction
q0_f(input[i]) = true is matched prediction
table with headers interpreted as input to pattern levels
top down positional prediction
how to know row is header
row uses symbols already known
the symbols have children
others rows use data associated with correct prediction symbols with children use
the data is does not have a prediction function that correctly predicts symbols with children
if each item in row x can predict each item in a few other rows then it's the header
possible to make data have such wide prediction that not possible to find the header
header is usually the first row
bottom up prediction
sequence matching part of existing pattern visit upper levels and run prediction on input where currently reading
find "@" finding out it's part of higher level "email" symbol and running email prediction on current index of input
add in top down sequences with prediction functions into pattern levels before reading the table

expected input symbols
recognize bottom up and across
predict top down and across
for i, inputAtI := range input
if !recognize for input[i]
	run patternDetector(i, input[i])
else
	run [atomRecognized.prediction(i, input[i]) to build whatever expected structure or filter function]


atomRecognized.prediction
	if prediction fails
		remove data or send info to higher level prediction function
contextual state chart

computer code writing patterns and using parts of the pattern tree
to make pattern for when to put down pieces of text

higher level patterns from 1 graph (not same sequence but same if in between nodes were removed)
lower level patterns from different graph
input being multiple levels of structured sequence match the pattern structures the pattern detector makes
way for user to add shortcut words so user and stored patterns are on same page even with internal pattern names being generated
shortcut word happens at same time pattern happens
grid where 1 axis is time 1 axis is sequence
each point can be set to backtrack control to an earlier time and different sequence, replacing the simultaneous sequence
with a different sequence started earlier but comming after the sequence backtrack control was used from
1 axis for structure nodes to let backtrack commands be consistent for same structure
backtrack is true if prediction fails
making predictions while reading information
each element of the same property happening right next to other element in same time or same space is part of same group
pattern is loop
inhibition is when pattern stops

atom tree intersect with atom trees in timeline a
run timeline b at same time as a
atom tree interesction is the pattern
master time line for a and b

run only b
recognize atom tree as matching with intersect atom tree
find sibling patterns that was run at same time with b
run sibling pattern
do recognizing and running sibling pattern as same timestep as b

more than 1 timeline running means training
a partial match (keep differences found during intersection) during training means different data being added makes a new context on the state
first round training must use full match
highest number of node and content matches during intersection during non-training
each intersection atom tree has is separate to represent slightly different contexts among intersection trees
intesection, union
change in time and change in space is the pattern
save items from observe grid to table holding last tree data about data point
connect same data points together
edge is when 2 data points are different but they are at same time
numerical barrier data point that stops reading of timeline until a data point barrier of same number is read in a different timeline
all nested timelines must have a common theme so they don't collect nested timelines from other higher level timelines
the content in the higher level atom always wins
connecting data points across timeslines at same time and higher level time lines
compute the interesction nodes then use them to add hierarchy to timelines

intersect points on same line when there is a loop and the loop node holds position of timeline is was made from and looped points are 1 level below
intersect points on different lines at same time and let the higher level timeline name win if a lower level uses a timeline from a different theme
loops are separate timelines even if they start and end at same time as non loops
mattern match: highest in common count with weights stronger each level closer to root node
pattern match: loop match, finding right intersection node that's closes in common with input to start prediction or running siblings
program with if statements and conclusions
funnel paragraph with conclusion and premises
take the program sequences for if statements and conclusions,
match it into the funnel paragraph tree,
copy the level, but change the links so they link to the same lower words as their counterpart intersection nodes it to the funnel paragraph tree as new sub timeline,
make a new timeline where english works are now used in the sequence of if statements and conclusions
"condition" node of the program timeline will find the "condition" node of the english timeline
the "condition" node of the program timeline will copy itself under the english timeline,
but take the child nodes from the english timeline "condition" node

	
n timelines = n simultaneous data point changes
repeating across n timelines = hierarchy


0, move, 0, move, 2, move, 2, move
cycles length >= 1
	0: 0 move
	2: 2 move
repeats with n items before 1 item repeats
	move:
		move1: move 0
		move2: move 2

move1, barista, move1, barista, move2, barista
cycles length >= 1
	move1: move1 barista
repeats with n items before 1 item repeats
	barista
		barista1: barista move1
		barista2: barista move2
	

y = 1/2 x

n time to go 2 units of x axis
y/n units each time n for 1 unit of y axis
convert slope into time path of slightly changing x, y values

hold y=+-1x diagonals and straight lines as the default slopes for finding the next color
if the points don't match the next expected color try all directions till a point matches
the matching point and the previous point can be used to calculate the slope for the non-default direction
timeline A has same point repeated at same time timeline B has points
A's point is repeated enough times it can be used as a shortcut for B's points

for all bottom level sequences found
intersect atom trees
if no match
go up 1 level
if match
stop


predict(match what is stored with input) and fit(intersection with small atom trees. if no match move up 1 level and repeat with next level of atom trees) sequence to atom tree
keep items stored for longer period of time

{
	0: {
		// name will describe traversal changes when block is visited
		name: a,
		id: 0,

		parents: {
			// dimension -> parent id
			0: 3,
			1: 3,
			2: 14
		}
		components: [],

	},
	1: {
		name: b,
		parents: {
			0: [3]
		}
		components: [],
	},
	2: {
		name: c,
		parents: {
			1: [3, 4],
			2: [4],
			3: [4]
		}
		components: [],
	}
	3: {
		name: acba,
		parents: {
			0: [11]

		}
		a0 -> c0
		b0 -> a1
		sequence: {0: {0: {2: 0}, ....., 1: {0: {0: 1}}}}
		[0, 2, 1, 0],
		startNodes: {0: 0}
		children: {a: 0, b: 1, c: 2}
	}
	15: {
		name: x,
		parents: {
			0: [14]
		}
		components: [],
	},
	// block doesn't process until the full sequence matches
	14:	[ //  different sequence for context in different block
			[ // revisit block in same sequence
				{
					name: xacba,

					parents: {
						0: [11]

					}
					a0 -> c0
					b0 -> a1
					sequence: [(15, 0), (0, 2), (0, 0), (2, 0), ....., (1, 0), (0, 1)]

					[0, 2, 1, 0],
					startNodes: {15: 0}
					children: {a: 0, b: 1, c: 2}
				}
				{
					1: {
						// name can be same as in (14, 0) or different
						name: xacba,

					}
				}
			]
		[]
	]
	4: {
		name: accc,
		parents: {
			0: [11]
		}
		sequence: [0, 2, 2, 2]
		children: {a: 0, c: 2}

	}
	5: {
		name: " "
		parents: {
			1: [12]
		}
	}
	7: {
		name: w
		components: [],
	}
	8: {
		name: o
		components: [],
	}
	9: {
		name: r
		components: [],
	}
	10: {
		name: d
		components: [],
	}
	11: {
		name: word,
		parents: {
			0: [12]
			2: [12]
		}
		components: [7, 8, 9, 10],
	}
	
	12: {
		name: phrase,
		parents {
			position_in_sentence: id
		}
		components: [11, 5, 11]
		children: {word: 11, " ": 5}
	}
	13: {
		name: word,
		substate: {
			name: abstract
			parents: {
				0: [12]
				2: [12]
			}
			children: {accc: 4, acba: 1}
		}
	}
			
}

different paths through the same column
A is represented by 1 column, but A can be recognized by any usage of any row in the 1 column
certain symbols alter what is read next and written to next
intersect symbols to narrow down trackers to match rest of sequence
permenence value -> symbol id vector
permanence value drops over time
atrophy(time difference, permance value) = reduced permance value
set operation
equality operation
if statement
higher tracker waits until lower tracker meets it, recognizing lower blocks as the traversal
processing the logic
	1. reuse constructions
	2. everything is context
	3. multple threads can run the same logic simultaneously
	difference instances reusing same logic
n = p
1 tracker for n
1 tracker for p
making new connections and connecting existing structures in different ways
making new connections for same sequence
reusing existing connections but adjusting permanence values
adding new sequences
traverse tree until tracker is on a single block
single block is either 1 block or 1 block parent of 1 block sequence
make new sequence with value instead of field to bring the result up the tree
1 tracker to make new sequence with value instead of field
1 tracker on existing sequence to keep fields that haven't been replaced yet
1 program
	multiple people suggest how to change it
	changes often take parts from same program and different programs
	the changes don't have to fit the syntax

sequence l1
read and save

read and save the formula(word, " ", word)
find the closest formula to match with the sequence(autocomplete using word, " ", word)


standing on a color floor
have 4 maps, 1 large dot, 1 ring and 1 large dot, 2 parallel lines and 1 large dot, or neither
can't jump to se more of the floor
can't compare color you see on floor with maps
you only see 1 color where you stand and surroundings
can compare colors on the floor only
no guarantee of items on floor are centered
how to figure out what map is right

if you see a different color on the floor the 1 large dot map is wrong
if you follow the different color off the page than the 1 ring and 1 large dot is wrong
if you follow the different color and are able to arrive at the same place you started and you are still traveling on 1 color then 1 ring and 1 large dot is right



code
	code structure english phrases
		english words making up the phrase
		code


english
	english funnel essay english phrases
		english words making up the phrase
		english sentences

assume english words under code and english are the same words
read english funnel essay english phrases
recognize the code and english english words
use the sequence that does not actually predict the input(code structure english phrases)
link code structure english phrases to the english sentences as the code structure english phrases are linked to the code

sequences different but equivalent.



// frst item in each timeline defines the type
// use mapvalues to store the intvalue data for the table
// timeline id -> graph atom id
// contiguously says how to connect
// prediction says what needs to match and be connected
// hierarchy timelines
// each timeline is unique
// 1 state being run by multiple parent timelines
// how to know when we are at the nth child run(1 run is contiguous states)
// discontinuity breaks means new run of same timline
/*
	everything is a block or sequence of smaller blocks
	different sequences that are logically the same are doubly linked by the "same"
	property
	variables are found by insersecting, completing the sequence and finding trees that have different branches
	what happens if more than 1 parent connects to the same child
	{nodeId -> {parentNodeId: unrunChildNodeCount}}
	use goroutines for child nodes

	bottom up filter from child nodes to parent nodes
	parent nodes found are now input for parent nodes filter
	there should be 1 parent found at the top that is the top level formula for the input

	storing the formula for word first
	word formula
		word
			a
			at
			the
	using words and spaces to derive the formula for phrase
	finds word formula first, then fails to complete pattern. word is the highest formula
	so phrase is made using the input

	storing the letter formulas first


	d/dxc
		d/dx, c
	c
		constant

	d/dxx^n
		same
			nx^n-1
		d/dx
			d
			/
			d
			x
		x^n
			x
			^
			n
				digit
					self loop
					0
					1
					...
					9
	nx^n-1
		same
			d/dxx^n
		n
		x^n
			x
			^
			n
				n-1
					n
						digit
							self loop
						0
						1
						...
						9
					-
					1

	intersect sequences at top level
	traverse intersected part in counterpart sequence to find the node where branches diverge on
	searched sequence and counterpart sequence
	the node found is the variable
	use it as the substitution key for the countepart sequence and the input being evalulated

	n = n
		n
			same
				n
			digit
				check with same
				self loop
		n
			same
				n
			digit
				check with same
				self loop

	n = p
	n
		same
			p
		digit
			check with same
				if n == p
					stop running successive sequences in branch tree
				if n != p
					break complete sequence
			self loop
	p
		same
			n
		digit
			check with same
			self loop

	branch
		paths
			0
				condition1
				statement
			1
				condition2
				statement
			2
				statement

	while
		paths
			0
				condition1
				statement
				rerun condition1
					leave while if condition1 is false


	run each sequence in order and halt the moment the equivalence is broken

	how to know when a different sequence is logically the same

*/
// predict next string
// if fail
// 	1 table for if string has been seen
//  1 table for order of strings
// timelines only use strings
// tree diagram
/*
	*/
/*
	tree levels
	character level
	word level
	phrase level


	T for holding items across timelines
	item repeats across n timelines
	repeating across each timeline must not match at same timestep
*/
